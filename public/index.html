<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live App</title>
    <script src="/socket.io/socket.io.js"></script>
</head>
<style>
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }
    body, html {
        width: 100%;
        height: 100%;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    .parent {
        width: 100%;
        background:url("https://marketplace.canva.com/EAE6nxrydxw/1/0/1600w/canva-rose-pink-purple-organic-blob-shapes-beautiful-desktop-wallpaper-QWyrCrYYNMI.jpg");
        box-sizing: border-box;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
    }
    h4{
        color:black;
        margin-bottom: 10px;
        font-size: large;
    }
    .con {
        width: 500px;
        height: auto;
        border-radius: 10px;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        gap: 20px;
    
        color:black;
        padding: 50px 10px;
    }
    .search-con {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100%;
        padding: 0;
    }
    .password {
        width: 80%;
        height: 40px;
        padding: 3px 7px;
        border: 0.5px solid grey;

    }
    .search-but {
        width: 20%;
        height: 40px;
        border: none;
        background-color: yellow;
        box-shadow: inset 0px 0px 10px 1px black;
    }
    .search-but:hover {
        background-color: green;
        color: white;
        cursor: pointer;
    }
    .view-but {
        background-color: red;
        padding: 5px 19px;
        color: white;
        box-shadow: 0px 0px 10px 1px black;
        animation: view 1s infinite ease-in;
    }
    .view-but:hover {
        background-color: green;
        cursor: pointer;
    }
    .displayon {
        display: flex !important;
    }
    @keyframes view {
        0% {transform: scale(1);}
        50% {transform: scale(1.2);}
        100% {transform: scale(1);}
    }
    .show {
        width: 100%;
        height: 100%;
        background-color: rgba(26, 25, 25, 0.632);
        display: none;
        position: fixed;
        top: 0;
        left: 0;
    }
    .end {
       
        cursor: pointer;
        background-color: white;
        color:red;
        font-weight: bolder;
        border-radius: 4px;
        padding: 3px 10px;
        box-shadow:  0px 0px 10px 3px rgb(134, 133, 133);
    }
    .end-con{
        position: absolute;
        right: 40px;
        top: 20px;
        display: flex;
        flex-direction: row;
        gap:10px;
    }
    .camera-switch{
        cursor: pointer;
        background-color: white;
        border-radius: 4px;
        color:black;
        padding: 5px 10px;
        box-shadow:  0px 0px 10px 3px rgb(134, 133, 133);
        border:none;
    }
    .end:hover{
        transform: scale(1.09);
        opacity: 0.7;
        
    }
    .camera-switch:hover{
        transform: scale(1.09);
       opacity: 0.7;
    }
    #video {
        width: 100%;
        height: 100%;
        transform: scaleX(-1);
        background-color: white;
    }
    @media (max-width: 800px) {
.con{
    width:98%;
    height:auto;
    padding:60px 10px;


}
}
.activeusers{
    position: fixed;
    top:20px;
    left:20px; 
    z-index: 2;
    font-weight: bolder;
   
}
</style>
<body>
    <div class="parent">
        <p class="activeusers"></p>
        <h4>Gudd morning...ðŸ™„</h4>
        <div class="con">
            <p>You can only see if the user is active with the key</p>
            <div class="search-con">
             
                <input class="password" placeholder="type key" type="text">
                <button class="search-but">View</button>
            </div>
            <h3>Or</h3>
            <p class="view-but">Go live</p>
        </div>
    </div>
    <div class="show">
        <video id="video" autoplay ></video>
        <div class="end-con">
         
            <p class="end">END</p>
        </div>
      
    </div>

    <script>
        //   <button class="camera-switch">switch camera</button>
        const socket = io();
        let apiurl = "https://liveapp-wwzq.onrender.com";
        let apiur = "http://localhost:4000";
        const video = document.getElementById("video");
        const show = document.querySelector(".show");
        const password = document.querySelector(".password");
        const searchbut = document.querySelector(".search-but");
        const viewbut = document.querySelector(".view-but");
        const end = document.querySelector(".end");
        const activeusers = document.getElementsByClassName("activeusers")[0];
    
        let userid, key, localStream,st;
        let peerConnection, peerConnectionview;
        let viewerid;
     

    //
    const iceServers = [
            { urls: "stun:stun2.l.google.com:19302" },
            {
                urls: 'turn:relay1.expressturn.com:3478',
                username: 'efT5G6CG5SW92BXA9E',
                credential: 'FVLSr0MIWhh0RCrl'
            }
        ];
        const iceServe = [
            { urls: "stun:stun2.l.google.com:19302" },
            {
    url: 'turn:numb.viagenie.ca',
    credential: 'muazkh',
    username: 'webrtc@live.com'
    
},]

    ///listofactiveusers
    socket.on("listofactive",(d)=>{
      console.log("number of active person on page",d)
      activeusers.textContent = `Active users: ${d-1} person right now`;

    })
    ////

        /////////////////////// Code start here ///////////////////////
    
        socket.on("vieweridget", (d) => {
            userid = d;
            console.log("Received viewer ID:", d);
        });
    
        socket.emit("viewer", "Hello, this is thet naing tun");
    
        async function fetchPost(url, data) {
            console.log("Sending POST request to:", url, "with data:", data);
            try {
                const response = await fetch(url, {
                    method: "POST",
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ key: data, userid: userid })
                });
                return response;
            } catch (error) {
                console.error("Error in fetchPost:", error);
            }
        }
    
        searchbut.addEventListener("click", async () => {
            const inputval = password.value.trim();
            console.log("Search button clicked with key:", inputval);
            if (!inputval) return;
            let url = `${apiurl}/find`;
            let response = await fetchPost(url, inputval);
            if (response.status === 200) {
                show.classList.add("displayon");
                const data = await response.json();
                key = data.key;
                socket.emit("imconnect", { key, userid, liveusersocket: data.liveusersocket });
                console.log("Connected as viewer with key:", key);
            } else {
                console.error("No user found with key:", inputval);
                alert("No user with this key!");
            }
        });
        let useFrontCamera = false;

        const constraints = {
        video: {
            facingMode: useFrontCamera ? "user" : "environment" // "user" for front, "environment" for back
        }
    };

        viewbut.addEventListener("click", async () => {
            console.log("Going live...");
            key = prompt("Enter a key and share it with your audience.");
            if (!key) return;
            let url = `${apiurl}/hoster`;
            let response = await fetchPost(url, key);
            if (response.status === 200) {
                show.classList.add("displayon");
    
                let stream = await navigator.mediaDevices.getUserMedia({video:true});
               video.srcObject = stream;
    
            } else {
                console.error("Failed to create a key");
                alert("Please create a key");
            }
        });

    ///////////////// streamer-start here ///////////////////////
        socket.on("viewer-connected", async (d) => {
          
            console.log("Viewer connected:", d);
            peerConnection = new RTCPeerConnection({
                iceServers
                
            });
    
            peerConnection.onicecandidate = event => {
                if (event.candidate) {
                    console.log("âœ… Received ICE Candidate:", event.candidate);
                    socket.emit("ice-candidate", { to: d.from, from: userid, key: key, candidate: event.candidate });
                } else {
                    console.log("ðŸš€ ICE Candidate gathering complete!");
                }
            };
    
           
    
            try {
              
                 st = await navigator.mediaDevices.getUserMedia({video:true});
               
        st.getTracks().forEach(track => peerConnection.addTrack(track, st));
       
                const offer = await peerConnection.createOffer();
                console.log("Created offer:", offer);
                await peerConnection.setLocalDescription(new RTCSessionDescription(offer));
                console.log("Sending offer to viewer:", peerConnection.localDescription);
                socket.emit("offer", { to: d.from, from: userid, key: key, offer: peerConnection.localDescription });
            } catch (error) {
                console.error("Error in creating offer:", error);
            }
    
            peerConnection.oniceconnectionstatechange = () => {
                console.log("Streamer ICE connection state:", peerConnection.iceConnectionState);
            };
        });
        socket.on("answer", (data) => {
            console.log("Received answer:", data);
            if (peerConnection) {
                peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
            }
        });
    
    //////////////////////// viewer-start ////////////////////////
        socket.on('offer', async (d) => {
            console.log("Received offer from streamer:", d);
    
            peerConnectionview = new RTCPeerConnection({
                iceServers  // Force relay when needed
            });
    
            peerConnectionview.onicecandidate = event => {
                if (event.candidate) {
                    console.log(`âœ… Received ICE Candidate:from${d.from}`, event.candidate);
                    socket.emit("ice-candidate", { to: d.from, candidate: event.candidate, from: userid });
                } else {
                    console.log("ðŸš€ ICE Candidate gathering complete!");
                }
            };
    
            
            peerConnectionview.ontrack = event => {
                console.log(event.streams[0],"geting video")
                video.srcObject = event.streams[0];
               
                
            };
           
    
            try {
                await peerConnectionview.setRemoteDescription(new RTCSessionDescription(d.offer));
    
                const answer = await peerConnectionview.createAnswer();
                console.log("Answer created with SDP:", answer.sdp);
    
                await peerConnectionview.setLocalDescription(answer);
                console.log("Sending answer to streamer:", answer);
                socket.emit('answer', { to: d.from, answer: peerConnectionview.localDescription, from: userid });
            } catch (error) {
                alert("error in proessingggg")
                console.error("Error in processing offer:", error);
            }
    
            peerConnectionview.oniceconnectionstatechange = () => {
                console.log("Viewer ICE connection state:11111111", peerConnectionview.iceConnectionState);
            };
        });
    
        socket.on("ice-candidate", (data) => {
            
            try {
                if (peerConnection) {
                    peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
                    console.log("Received ICE candidate peer:", data);
                } else if (peerConnectionview) {
                    peerConnectionview.addIceCandidate(new RTCIceCandidate(data.candidate));
                    console.log("Received ICE candidate peerview:", data);
                }
            } catch (error) {
                console.error("Error adding ICE candidate:", error);
            }
        });
    
 /////////////////// end-button ////////////////////////////     
        end.addEventListener("click", async () => {
            console.log("Ending stream...");
            let url = `${apiurl}/end`;
            if(peerConnection){
     
        let response = await fetchPost(url, key);
          
          if (response.status === 200) {
              location.reload()
   
    
              console.log("Stream ended successfully");
             
          } else {
              console.error("Failed to end stream");
          }

    
   
            }else{
                location.reload()
            }
         
        });
      

    </script>
    
</body>
</html>
